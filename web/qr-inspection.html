<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QRåŒæ¢±ç‰©æ¤œå“ç”»é¢ - qr-scanner</title>
    
    <!-- ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯¾ç­– -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- QR Scannerãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
    <script src="https://unpkg.com/qr-scanner@1.4.2/qr-scanner.umd.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
            padding: 20px;
        }
        
        .header {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        
        .header h1 {
            color: #667eea;
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .header p {
            color: #666;
            font-size: 14px;
        }
        
        .screen {
            display: none;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 30px;
            flex: 1;
        }
        
        .screen.active {
            display: block;
        }
        
        /* åˆæœŸç”»é¢ */
        .start-screen {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .start-icon {
            font-size: 80px;
            margin-bottom: 20px;
        }
        
        .start-screen h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 28px;
        }
        
        .start-screen p {
            color: #666;
            margin-bottom: 30px;
            font-size: 16px;
        }
        
        .shipment-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            margin-bottom: 20px;
            display: inline-block;
        }
        
        /* ãƒœã‚¿ãƒ³ */
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #e0e0e0;
        }
        
        .btn-success {
            background: #10b981;
            color: white;
        }
        
        .btn-danger {
            background: #ef4444;
            color: white;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }
        
        /* ã‚«ãƒ¡ãƒ©ç”»é¢ */
        .camera-container {
            position: relative;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
            aspect-ratio: 4/3;
        }
        
        #camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .scan-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 250px;
            height: 250px;
            border: 2px dashed rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            pointer-events: none;
        }
        
        .scan-corners {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 250px;
            height: 250px;
            pointer-events: none;
        }
        
        .corner {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 4px solid #10b981;
        }
        
        .corner-tl { top: -4px; left: -4px; border-right: none; border-bottom: none; }
        .corner-tr { top: -4px; right: -4px; border-left: none; border-bottom: none; }
        .corner-bl { bottom: -4px; left: -4px; border-right: none; border-top: none; }
        .corner-br { bottom: -4px; right: -4px; border-left: none; border-top: none; }
        
        @keyframes scan-animation {
            0%, 100% { top: 0%; }
            50% { top: 100%; }
        }
        
        .scan-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #10b981, transparent);
            animation: scan-animation 2s ease-in-out infinite;
        }
        
        .camera-status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
        }
        
        .calibration-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        .calibration-box {
            background: white;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .calibration-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        /* çµæœç”»é¢ */
        .result-screen {
            text-align: center;
        }
        
        .result-icon {
            font-size: 80px;
            margin-bottom: 20px;
        }
        
        .result-screen h2 {
            color: #10b981;
            margin-bottom: 20px;
            font-size: 28px;
        }
        
        .qr-result-box {
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }
        
        .qr-result-label {
            color: #666;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .qr-result-value {
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            color: #333;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
        .status-message {
            margin-bottom: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
            animation: slideDown 0.3s ease-out;
        }
        
        .status-message.show {
            display: block;
        }
        
        .status-message.info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #60a5fa;
        }
        
        .status-message.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #34d399;
        }
        
        .status-message.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #f87171;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ« */
        .debug-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-width: 300px;
            z-index: 1000;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
        }
        
        .debug-panel.show {
            display: block;
        }
        
        .debug-title {
            color: #ffff00;
            font-weight: bold;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
            margin-bottom: 10px;
            font-size: 13px;
        }
        
        .debug-row {
            margin-bottom: 6px;
        }
        
        .debug-label {
            color: #00ccff;
            display: inline-block;
            min-width: 100px;
        }
        
        .debug-value {
            color: #00ff00;
        }
        
        /* ã‚¨ãƒ©ãƒ¼ç”»é¢ */
        .error-screen {
            text-align: center;
        }
        
        .error-icon {
            font-size: 80px;
            margin-bottom: 20px;
        }
        
        .error-screen h2 {
            color: #ef4444;
            margin-bottom: 15px;
        }
        
        .error-message {
            background: #fee2e2;
            border: 1px solid #f87171;
            border-radius: 8px;
            padding: 15px;
            color: #991b1b;
            margin: 20px 0;
        }
        
        .error-guide {
            background: #dbeafe;
            border: 1px solid #60a5fa;
            border-radius: 8px;
            padding: 20px;
            text-align: left;
            margin: 20px 0;
        }
        
        .error-guide h3 {
            color: #1e40af;
            margin-bottom: 15px;
        }
        
        .error-guide ol {
            color: #1e40af;
            padding-left: 20px;
        }
        
        .error-guide li {
            margin-bottom: 8px;
        }
        
        /* ãƒ•ãƒƒã‚¿ãƒ¼ */
        .footer {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            text-align: center;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .footer p {
            color: #666;
            font-size: 12px;
            margin: 5px 0;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 20px;
            }
            
            .scan-overlay,
            .scan-corners {
                width: 200px;
                height: 200px;
            }
            
            .debug-panel {
                top: 10px;
                right: 10px;
                max-width: 250px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <div class="header">
            <h1>ğŸ“± QRåŒæ¢±ç‰©æ¤œå“ç”»é¢ (qr-scanner)</h1>
            <p>Safariæœ€é©åŒ–ç‰ˆ v2.1 - Phase 1&2å®Œå…¨å®Ÿè£…</p>
        </div>
        
        <!-- åˆæœŸç”»é¢ -->
        <div class="screen active" id="start-screen">
            <div class="start-screen">
                <div class="start-icon">ğŸ“·</div>
                <h2>QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³</h2>
                <p id="shipment-info" class="shipment-info" style="display:none;"></p>
                <p>ã‚«ãƒ¡ãƒ©ã§QRã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿å–ã‚Šã¾ã™</p>
                <button class="btn btn-primary" id="btn-start-scan">
                    ğŸ“· ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹
                </button>
                <button class="btn btn-secondary" id="btn-back-to-ship" style="display:none; margin-top: 15px;">
                    â† å‡ºè·æ¤œå“ç”»é¢ã«æˆ»ã‚‹
                </button>
            </div>
        </div>
        
        <!-- ã‚«ãƒ¡ãƒ©ç”»é¢ -->
        <div class="screen" id="camera-screen">
            <div id="status-message" class="status-message"></div>
            
            <div class="camera-container">
                <video id="camera-video" playsinline muted webkit-playsinline></video>
                
                <!-- ã‚¹ã‚­ãƒ£ãƒ³ã‚¬ã‚¤ãƒ‰ -->
                <div class="scan-overlay"></div>
                <div class="scan-corners">
                    <div class="corner corner-tl"></div>
                    <div class="corner corner-tr"></div>
                    <div class="corner corner-bl"></div>
                    <div class="corner corner-br"></div>
                </div>
                <div class="scan-line" id="scan-line" style="display:none;"></div>
                
                <!-- ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ -->
                <div class="calibration-overlay" id="calibration-overlay" style="display:none;">
                    <div class="calibration-box">
                        <div class="calibration-icon">âš™ï¸</div>
                        <h3>ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­</h3>
                        <p>ã‚«ãƒ¡ãƒ©ã‚’èª¿æ•´ã—ã¦ã„ã¾ã™...</p>
                    </div>
                </div>
                
                <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ -->
                <div class="camera-status" id="camera-status">åˆæœŸåŒ–ä¸­...</div>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-secondary" id="btn-manual-input">âœï¸ æ‰‹å‹•å…¥åŠ›</button>
                <button class="btn btn-secondary" id="btn-switch-camera">ğŸ”„ ã‚«ãƒ¡ãƒ©åˆ‡æ›¿</button>
                <button class="btn btn-secondary" id="btn-toggle-debug">ğŸ› Debug</button>
                <button class="btn btn-danger" id="btn-stop-scan">â¹ï¸ åœæ­¢</button>
            </div>
        </div>
        
        <!-- çµæœç”»é¢ -->
        <div class="screen" id="result-screen">
            <div class="result-screen">
                <div class="result-icon">âœ…</div>
                <h2>ã‚¹ã‚­ãƒ£ãƒ³å®Œäº†</h2>
                
                <div class="qr-result-box">
                    <div class="qr-result-label">ğŸ“„ èª­ã¿å–ã‚Šçµæœ</div>
                    <div class="qr-result-value" id="qr-result"></div>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-primary" id="btn-copy-result">ğŸ“‹ ã‚³ãƒ”ãƒ¼</button>
                    <button class="btn btn-secondary" id="btn-rescan">ğŸ”„ å†ã‚¹ã‚­ãƒ£ãƒ³</button>
                    <button class="btn btn-success" id="btn-share" style="display:none;">ğŸ“¤ å…±æœ‰</button>
                </div>
                <div class="btn-group" style="margin-top: 15px;">
                    <button class="btn btn-secondary" id="btn-back-to-ship-result" style="display:none;">
                        â† å‡ºè·æ¤œå“ç”»é¢ã«æˆ»ã‚‹
                    </button>
                </div>
            </div>
        </div>
        
        <!-- ã‚¨ãƒ©ãƒ¼ç”»é¢ -->
        <div class="screen" id="error-screen">
            <div class="error-screen">
                <div class="error-icon">âŒ</div>
                <h2>ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼</h2>
                
                <div class="error-message" id="error-message-text"></div>
                
                <div class="error-guide">
                    <h3>ğŸ”§ è§£æ±ºæ–¹æ³•ï¼ˆiOS Safariï¼‰</h3>
                    <ol>
                        <li>è¨­å®šã‚¢ãƒ—ãƒªã‚’é–‹ã</li>
                        <li>Safari ã‚’é¸æŠ</li>
                        <li>ã‚«ãƒ¡ãƒ© ã‚’é¸æŠ</li>
                        <li>"è¨±å¯" ã¾ãŸã¯ "ç¢ºèª" ã‚’é¸æŠ</li>
                        <li>ã“ã®ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿</li>
                    </ol>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-primary" id="btn-retry">ğŸ”„ å†è©¦è¡Œ</button>
                    <button class="btn btn-secondary" onclick="window.location.reload()">â™»ï¸ å†èª­ã¿è¾¼ã¿</button>
                </div>
            </div>
        </div>
        
        <!-- ãƒ•ãƒƒã‚¿ãƒ¼ -->
        <div class="footer">
            <p>ğŸ”’ HTTPSç’°å¢ƒã§å®‰å…¨ã«å‹•ä½œ</p>
            <p>Safariæœ€é©åŒ–ç‰ˆ v2.1 (Phase 1&2å®Œå…¨å®Ÿè£…)</p>
        </div>
    </div>
    
    <!-- ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ« -->
    <div class="debug-panel" id="debug-panel">
        <div class="debug-title">ğŸ› Debug Info</div>
        <div class="debug-row"><span class="debug-label">ğŸ“¹ Camera:</span> <span class="debug-value" id="debug-camera">-</span></div>
        <div class="debug-row"><span class="debug-label">ğŸ“ Resolution:</span> <span class="debug-value" id="debug-resolution">-</span></div>
        <div class="debug-row"><span class="debug-label">ğŸ¬ ReadyState:</span> <span class="debug-value" id="debug-ready">-</span></div>
        <div class="debug-row"><span class="debug-label">ğŸ“¡ Stream:</span> <span class="debug-value" id="debug-stream">-</span></div>
        <div class="debug-row"><span class="debug-label">ğŸ” Detection:</span> <span class="debug-value" id="debug-detection">-</span></div>
        <div class="debug-row"><span class="debug-label">ğŸ”¢ Frames:</span> <span class="debug-value" id="debug-frames">0</span></div>
        <div class="debug-row"><span class="debug-label">ğŸ“Š Scan Rate:</span> <span class="debug-value" id="debug-scanrate">-</span></div>
        <div class="debug-row"><span class="debug-label">âš¡ Method:</span> <span class="debug-value" id="debug-method">-</span></div>
        <div class="debug-row"><span class="debug-label">ğŸ iOS:</span> <span class="debug-value" id="debug-ios">-</span></div>
        <div class="debug-row"><span class="debug-label">â±ï¸ Uptime:</span> <span class="debug-value" id="debug-uptime">0s</span></div>
    </div>
    
    <script>
        class QRScannerApp {
            constructor() {
                // åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
                this.video = document.getElementById('camera-video');
                this.stream = null;
                this.isScanning = false;
                this.qrScanner = null;
                this.currentCamera = 'environment';  // èƒŒé¢ã‚«ãƒ¡ãƒ©
                this.cameras = [];
                this.cameraIndex = 0;
                
                // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                this.calibrationAttempts = 0;
                this.maxCalibrationAttempts = 3;
                this.isCalibrating = false;
                
                // ãƒ‡ãƒãƒƒã‚°
                this.debugMode = false;
                this.debugUpdateInterval = null;
                this.frameCount = 0;
                this.scanStartTime = 0;
                this.detectionMethod = 'none';
                this.lastDetectionAttempt = 0;
                
                // QRçµæœ
                this.lastQRValue = '';
                
                this.init();
            }
            
            init() {
                this.initElements();
                this.initEventListeners();
                this.initPageLifecycle();
                this.detectCameras();
                this.checkShipmentInfo();
                
                // å…±æœ‰APIå¯¾å¿œãƒã‚§ãƒƒã‚¯
                if (navigator.share) {
                    document.getElementById('btn-share').style.display = 'inline-flex';
                }
            }
            
            checkShipmentInfo() {
                // å‡ºè·IDãƒã‚§ãƒƒã‚¯
                const shipmentId = sessionStorage.getItem('qr-inspection-shipment-id');
                const returnUrl = sessionStorage.getItem('qr-inspection-return-url');
                
                if (shipmentId) {
                    // å‡ºè·IDè¡¨ç¤º
                    const shipmentInfo = document.getElementById('shipment-info');
                    shipmentInfo.textContent = `ğŸ“¦ å‡ºè·ID: ${shipmentId}`;
                    shipmentInfo.style.display = 'inline-block';
                    
                    // æˆ»ã‚‹ãƒœã‚¿ãƒ³è¡¨ç¤º
                    const backButton = document.getElementById('btn-back-to-ship');
                    const backButtonResult = document.getElementById('btn-back-to-ship-result');
                    backButton.style.display = 'inline-flex';
                    backButtonResult.style.display = 'inline-flex';
                    
                    // æˆ»ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
                    backButton.addEventListener('click', () => this.backToShip());
                    backButtonResult.addEventListener('click', () => this.backToShip());
                }
            }
            
            backToShip() {
                const returnUrl = sessionStorage.getItem('qr-inspection-return-url');
                if (returnUrl) {
                    // QRã‚¹ã‚­ãƒ£ãƒ³çµæœã‚’ä¿å­˜ï¼ˆå¿…è¦ãªå ´åˆï¼‰
                    if (this.lastQRValue) {
                        sessionStorage.setItem('qr-scan-result', this.lastQRValue);
                    }
                    // å‡ºè·æ¤œå“ç”»é¢ã«æˆ»ã‚‹
                    window.location.href = returnUrl;
                } else {
                    // æˆ»ã‚‹URLãŒãªã„å ´åˆã¯ship.htmlã«æˆ»ã‚‹
                    window.location.href = 'ship.html';
                }
            }
            
            initElements() {
                // ç”»é¢
                this.screens = {
                    start: document.getElementById('start-screen'),
                    camera: document.getElementById('camera-screen'),
                    result: document.getElementById('result-screen'),
                    error: document.getElementById('error-screen')
                };
                
                // ãƒœã‚¿ãƒ³
                this.buttons = {
                    startScan: document.getElementById('btn-start-scan'),
                    stopScan: document.getElementById('btn-stop-scan'),
                    manualInput: document.getElementById('btn-manual-input'),
                    switchCamera: document.getElementById('btn-switch-camera'),
                    toggleDebug: document.getElementById('btn-toggle-debug'),
                    copyResult: document.getElementById('btn-copy-result'),
                    rescan: document.getElementById('btn-rescan'),
                    share: document.getElementById('btn-share'),
                    retry: document.getElementById('btn-retry'),
                    backToShip: document.getElementById('btn-back-to-ship'),
                    backToShipResult: document.getElementById('btn-back-to-ship-result')
                };
                
                // UIè¦ç´ 
                this.statusMessage = document.getElementById('status-message');
                this.cameraStatus = document.getElementById('camera-status');
                this.scanLine = document.getElementById('scan-line');
                this.calibrationOverlay = document.getElementById('calibration-overlay');
                this.qrResult = document.getElementById('qr-result');
                this.errorMessageText = document.getElementById('error-message-text');
                this.debugPanel = document.getElementById('debug-panel');
            }
            
            initEventListeners() {
                this.buttons.startScan.addEventListener('click', () => this.startScan());
                this.buttons.stopScan.addEventListener('click', () => this.stopScan());
                this.buttons.manualInput.addEventListener('click', () => this.manualInput());
                this.buttons.switchCamera.addEventListener('click', () => this.switchCamera());
                this.buttons.toggleDebug.addEventListener('click', () => this.toggleDebug());
                this.buttons.copyResult.addEventListener('click', () => this.copyToClipboard());
                this.buttons.rescan.addEventListener('click', () => this.rescan());
                this.buttons.share.addEventListener('click', () => this.shareResult());
                this.buttons.retry.addEventListener('click', () => this.startScan());
            }
            
            // Phase 1: BFCacheå®Œå…¨å¯¾å¿œ
            initPageLifecycle() {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        if (this.isScanning) this.pauseScanning();
                    } else {
                        if (this.isScanning) setTimeout(() => this.resumeScanning(), 500);
                    }
                });
                
                window.addEventListener('pagehide', (event) => {
                    console.log('[BFCache] pagehide - persisted:', event.persisted);
                    this.cleanupResources();
                    if (this.isScanning) {
                        sessionStorage.setItem('qr-scanner-was-active', 'true');
                    }
                });
                
                window.addEventListener('pageshow', (event) => {
                    if (event.persisted) {
                        console.log('[BFCache] pageshow - restored from cache');
                        this.cleanupResources();
                        const wasActive = sessionStorage.getItem('qr-scanner-was-active');
                        if (wasActive === 'true') {
                            sessionStorage.removeItem('qr-scanner-was-active');
                            this.showScreen('start');
                        }
                    }
                });
                
                window.addEventListener('freeze', () => {
                    console.log('[BFCache] freeze');
                    this.cleanupResources();
                });
                
                window.addEventListener('resume', () => {
                    console.log('[BFCache] resume');
                    if (this.isScanning) this.calibrateCamera();
                });
                
                window.addEventListener('beforeunload', () => {
                    this.cleanupResources();
                });
            }
            
            async detectCameras() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.cameras = devices.filter(device => device.kind === 'videoinput');
                    
                    console.log(`[Camera] Detected ${this.cameras.length} camera(s):`, this.cameras);
                    this.updateDebug('camera', `${this.cameras.length} camera(s)`);
                    this.updateDebug('detection', `${this.cameras.length} cameras found`);
                    
                    // èƒŒé¢ã‚«ãƒ¡ãƒ©ã‚’å„ªå…ˆçš„ã«é¸æŠ
                    const backCameraIndex = this.cameras.findIndex(cam => 
                        cam.label.toLowerCase().includes('back') || 
                        cam.label.toLowerCase().includes('rear') ||
                        cam.label.toLowerCase().includes('environment')
                    );
                    
                    if (backCameraIndex !== -1) {
                        this.cameraIndex = backCameraIndex;
                        console.log(`[Camera] Found back camera at index ${backCameraIndex}`);
                    }
                } catch (error) {
                    console.warn('ã‚«ãƒ¡ãƒ©æ¤œå‡ºã‚¨ãƒ©ãƒ¼:', error);
                    this.updateDebug('detection', 'Camera detection failed');
                }
            }
            
            showScreen(name) {
                Object.values(this.screens).forEach(screen => screen.classList.remove('active'));
                this.screens[name].classList.add('active');
            }
            
            showStatus(message, type = 'info') {
                this.statusMessage.textContent = message;
                this.statusMessage.className = `status-message show ${type}`;
                
                setTimeout(() => {
                    this.statusMessage.classList.remove('show');
                }, 3000);
            }
            
            updateCameraStatus(message) {
                this.cameraStatus.textContent = message;
            }
            
            async startScan() {
                try {
                    this.calibrationAttempts = 0;
                    this.frameCount = 0;
                    this.scanStartTime = Date.now();
                    
                    this.showScreen('camera');
                    await this.initializeCamera();
                } catch (error) {
                    this.handleError(error);
                }
            }
            
            async initializeCamera() {
                let constraints;
                
                if (this.cameras.length > 0 && this.cameras[this.cameraIndex]) {
                    constraints = {
                        video: {
                            deviceId: { exact: this.cameras[this.cameraIndex].deviceId },
                            width: { ideal: 1280, max: 1920 },
                            height: { ideal: 720, max: 1080 },
                            frameRate: { ideal: 30, max: 30 }
                        }
                    };
                    console.log(`[Camera] Using camera ${this.cameraIndex}: ${this.cameras[this.cameraIndex].label}`);
                } else {
                    constraints = {
                        video: {
                            facingMode: this.currentCamera,
                            width: { ideal: 1280, max: 1920 },
                            height: { ideal: 720, max: 1080 },
                            frameRate: { ideal: 30, max: 30 }
                        }
                    };
                    console.log(`[Camera] Using facingMode: ${this.currentCamera}`);
                }
                
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    this.updateDebug('stream', 'Connected');
                    
                    const videoTrack = this.stream.getVideoTracks()[0];
                    const settings = videoTrack.getSettings();
                    this.updateDebug('camera', videoTrack.label || 'Unknown');
                    console.log('[Camera] Settings:', settings);
                    
                    this.video.setAttribute('playsinline', true);
                    this.video.setAttribute('webkit-playsinline', true);
                    this.video.muted = true;
                    
                    await this.waitForVideoReady();
                    this.isScanning = true;
                    await this.calibrateCamera();
                } catch (error) {
                    console.error('[Camera] Initialization error:', error);
                    
                    // Phase 2: ã‚«ãƒ¡ãƒ©ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    if (this.cameras.length > 1 && this.cameraIndex < this.cameras.length - 1) {
                        console.log('[Camera] Trying next camera...');
                        this.cameraIndex++;
                        return this.initializeCamera();
                    }
                    
                    throw error;
                }
            }
            
            async waitForVideoReady() {
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        console.warn('[Video] Initialization timeout, but continuing...');
                        if (this.video.readyState >= 2) {
                            resolve();
                        } else {
                            reject(new Error('ãƒ“ãƒ‡ã‚ªåˆæœŸåŒ–ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'));
                        }
                    }, 15000);
                    
                    const checkReady = () => {
                        // readyState 3ä»¥ä¸Š AND videoWidth/HeightãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
                        if (this.video.readyState >= 3 && this.video.videoWidth > 0 && this.video.videoHeight > 0) {
                            clearTimeout(timeout);
                            console.log('[Video] Ready:', {
                                readyState: this.video.readyState,
                                size: `${this.video.videoWidth}x${this.video.videoHeight}`
                            });
                            
                            // å†ç”Ÿé–‹å§‹
                            this.video.play()
                                .then(() => {
                                    console.log('[Video] Playback started successfully');
                                    // æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒç¢ºå®Ÿã«æç”»ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
                                    this.waitForFirstFrame().then(resolve).catch(reject);
                                })
                                .catch(error => {
                                    console.warn('[Video] Playback error, but continuing:', error);
                                    // autoplayãŒåŠ¹ã„ã¦ã„ã‚‹å ´åˆã‚„ã€ã™ã§ã«å†ç”Ÿä¸­ã®å ´åˆã¯ç¶šè¡Œ
                                    this.waitForFirstFrame().then(resolve).catch(reject);
                                });
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    
                    // loadedmetadataã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                    const onMetadataLoaded = () => {
                        console.log('[Video] Metadata loaded');
                        setTimeout(checkReady, 100);
                    };
                    
                    this.video.removeEventListener('loadedmetadata', onMetadataLoaded);
                    this.video.addEventListener('loadedmetadata', onMetadataLoaded, { once: true });
                    
                    // å³åº§ã«ãƒã‚§ãƒƒã‚¯é–‹å§‹
                    checkReady();
                });
            }
            
            // æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒæç”»ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿï¼ˆSafariæœ€é©åŒ–ï¼‰
            async waitForFirstFrame() {
                return new Promise((resolve) => {
                    let attempts = 0;
                    const maxAttempts = 50; // 5ç§’é–“è©¦è¡Œ

                    const checkFrame = () => {
                        attempts++;
                        
                        // videoWidth/HeightãŒæœ‰åŠ¹ã§ã€readyStateãŒ4ï¼ˆå®Œå…¨æº–å‚™å®Œäº†ï¼‰
                        if (this.video.readyState === 4 && this.video.videoWidth > 0 && this.video.videoHeight > 0) {
                            console.log(`[Video] First frame ready after ${attempts * 100}ms`);
                            // ã•ã‚‰ã«å®‰å®šã‚’å¾…ã¤
                            setTimeout(resolve, 500);
                        } else if (attempts >= maxAttempts) {
                            console.warn('[Video] First frame timeout, proceeding anyway');
                            resolve(); // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¦ã‚‚ç¶šè¡Œ
                        } else {
                            setTimeout(checkFrame, 100);
                        }
                    };

                    setTimeout(checkFrame, 100);
                });
            }
            
            async calibrateCamera() {
                if (this.isCalibrating || this.calibrationAttempts >= this.maxCalibrationAttempts) {
                    return this.startQRDetection();
                }
                
                this.isCalibrating = true;
                this.calibrationAttempts++;
                
                this.calibrationOverlay.style.display = 'flex';
                this.updateCameraStatus(`ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­... (${this.calibrationAttempts}/${this.maxCalibrationAttempts})`);
                
                // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æœŸé–“ã‚’å»¶é•·ï¼ˆSafariæœ€é©åŒ–: åˆå›èµ·å‹•ã®å®‰å®šæ€§å‘ä¸Šï¼‰
                const calibrationDelay = this.calibrationAttempts === 1 ? 4000 : 2000; // åˆå›ã¯4ç§’
                console.log(`[Calibration] Waiting ${calibrationDelay}ms for camera stabilization...`);
                await new Promise(resolve => setTimeout(resolve, calibrationDelay));
                
                // ãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒå®Œå…¨ã«å®‰å®šã—ã¦ã„ã‚‹ã‹ç¢ºèª
                const isFullyReady = this.video.readyState === 4 && 
                                    this.video.videoWidth > 0 && 
                                    this.video.videoHeight > 0 &&
                                    !this.video.paused;
                
                this.calibrationOverlay.style.display = 'none';
                this.isCalibrating = false;
                
                if (isFullyReady) {
                    console.log(`[Calibration] âœ… Success on attempt ${this.calibrationAttempts} - Video: ${this.video.videoWidth}x${this.video.videoHeight}`);
                    // ã•ã‚‰ã«å°‘ã—å¾…æ©Ÿã—ã¦ã‹ã‚‰æ¤œå‡ºé–‹å§‹ï¼ˆå®‰å®šæ€§å‘ä¸Šï¼‰
                    setTimeout(() => this.startQRDetection(), 500);
                } else {
                    // ãƒ“ãƒ‡ã‚ªãŒã¾ã æº–å‚™ã§ãã¦ã„ãªã„å ´åˆã¯å†ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    console.warn(`[Calibration] âŒ Not ready (readyState: ${this.video.readyState}, size: ${this.video.videoWidth}x${this.video.videoHeight}, paused: ${this.video.paused})`);
                    if (this.calibrationAttempts < this.maxCalibrationAttempts) {
                        setTimeout(() => this.calibrateCamera(), 1000);
                    } else {
                        // æœ€å¤§è©¦è¡Œå›æ•°ã«é”ã—ãŸå ´åˆã§ã‚‚QRæ¤œå‡ºã‚’é–‹å§‹
                        console.warn('[Calibration] âš ï¸ Max attempts reached, starting detection anyway');
                        this.startQRDetection();
                    }
                }
            }
            
            async startQRDetection() {
                this.updateCameraStatus('QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ä¸­...');
                this.scanLine.style.display = 'block';
                this.updateDebug('detection', 'Starting');
                
                // iOS ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡º
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                
                if (typeof QrScanner !== 'undefined') {
                    try {
                        this.detectionMethod = 'QrScanner';
                        
                        this.qrScanner = new QrScanner(
                            this.video,
                            result => this.handleQRResult(result.data),
                            {
                                returnDetailedScanResult: true,
                                highlightScanRegion: false,
                                highlightCodeOutline: false,
                                maxScansPerSecond: isIOS ? 3 : 5,  // iOS: 3å›/ç§’ã€ãã®ä»–: 5å›/ç§’
                                preferredCamera: 'environment',  // èƒŒé¢ã‚«ãƒ¡ãƒ©å„ªå…ˆ
                                calculateScanRegion: this.calculateScanRegion.bind(this)
                            }
                        );
                        
                        await this.qrScanner.start();
                        this.updateDebug('detection', 'QrScanner active');
                        this.updateDebug('method', 'QrScanner');
                        console.log(`[QR] QrScanner started (iOS: ${isIOS}, rate: ${isIOS ? 3 : 5}/sec)`);
                        this.showStatus('QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ä¸­...', 'info');
                        this.startFrameCounter();
                    } catch (error) {
                        console.warn('QR Scanner failed, using fallback:', error);
                        this.showStatus('QrScannerã‚¨ãƒ©ãƒ¼ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸­...', 'error');
                        this.fallbackToManualDetection();
                    }
                } else {
                    console.warn('QrScanner library not available');
                    this.showStatus('QrScannerãƒ©ã‚¤ãƒ–ãƒ©ãƒªæœªæ¤œå‡ºã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸­...', 'error');
                    this.fallbackToManualDetection();
                }
            }
            
            // Phase 2: ã‚¹ã‚­ãƒ£ãƒ³é ˜åŸŸã®å‹•çš„è¨ˆç®—
            calculateScanRegion(video) {
                const { videoWidth, videoHeight } = video;
                const isPortrait = videoHeight > videoWidth;
                const baseSize = Math.min(videoWidth, videoHeight);
                const size = Math.round(baseSize * 0.6);
                const x = Math.round((videoWidth - size) / 2);
                const y = Math.round((videoHeight - size) / 2);
                
                return {
                    x: Math.max(0, x),
                    y: Math.max(0, y),
                    width: Math.min(size, videoWidth),
                    height: Math.min(size, videoHeight)
                };
            }
            
            // Phase 2: BarcodeDetector ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            fallbackToManualDetection() {
                if ('BarcodeDetector' in window) {
                    this.detectionMethod = 'BarcodeDetector';
                    const detector = new BarcodeDetector({ formats: ['qr_code'] });
                    
                    const detectQR = async () => {
                        if (this.isScanning && this.video.readyState === 4) {
                            try {
                                const currentTime = Date.now();
                                // iOSæœ€é©åŒ–: 200msé–“éš”ï¼ˆ5å›/ç§’ç›¸å½“ï¼‰
                                if (currentTime - this.lastDetectionAttempt > 200) {
                                    const barcodes = await detector.detect(this.video);
                                    this.lastDetectionAttempt = currentTime;
                                    
                                    if (barcodes.length > 0) {
                                        console.log('[QR] Detected via BarcodeDetector:', barcodes[0].rawValue);
                                        this.handleQRResult(barcodes[0].rawValue);
                                        return;
                                    }
                                }
                            } catch (error) {
                                console.warn('BarcodeDetector error:', error);
                            }
                        }
                        
                        if (this.isScanning) {
                            requestAnimationFrame(detectQR);
                        }
                    };
                    
                    detectQR();
                    this.updateDebug('detection', 'BarcodeDetector active');
                    this.updateDebug('method', 'BarcodeDetector');
                    this.showStatus('BarcodeDetectorã§ã‚¹ã‚­ãƒ£ãƒ³ä¸­...', 'info');
                    console.log('[QR] Fallback to BarcodeDetector');
                } else {
                    this.detectionMethod = 'none';
                    this.updateDebug('method', 'None (Error)');
                    console.error('[QR] No detection method available');
                    this.handleError(new Error('QRã‚³ãƒ¼ãƒ‰æ¤œå‡ºæ©Ÿèƒ½ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æœ€æ–°ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚'));
                }
            }
            
            startFrameCounter() {
                const countFrames = () => {
                    if (this.isScanning) {
                        this.frameCount++;
                        requestAnimationFrame(countFrames);
                    }
                };
                countFrames();
            }
            
            handleQRResult(data) {
                // é‡è¤‡æ¤œå‡ºé˜²æ­¢
                if (!this.isScanning) return;
                
                this.lastQRValue = data;
                this.updateDebug('detection', 'QR detected!');
                console.log('[QR] Detected:', data);
                
                // QRæ¤œå‡ºæ™‚ã¯ã‚¹ã‚­ãƒ£ãƒ³ã‚’åœæ­¢ã—ã¦ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                this.stopScan();
                this.showResult(data);
            }
            
            showResult(data) {
                this.qrResult.textContent = data;
                this.showScreen('result');
            }
            
            manualInput() {
                const input = prompt('QRã‚³ãƒ¼ãƒ‰ã®å†…å®¹ã‚’æ‰‹å…¥åŠ›ã—ã¦ãã ã•ã„:');
                if (input && input.trim()) {
                    this.handleQRResult(input.trim());
                }
            }
            
            // Phase 2: ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆ
            async switchCamera() {
                if (this.cameras.length <= 1) {
                    this.showStatus('åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ãªã‚«ãƒ¡ãƒ©ãŒã‚ã‚Šã¾ã›ã‚“', 'info');
                    return;
                }
                
                this.showStatus('ã‚«ãƒ¡ãƒ©ã‚’åˆ‡ã‚Šæ›¿ãˆã¦ã„ã¾ã™...', 'info');
                this.cameraIndex = (this.cameraIndex + 1) % this.cameras.length;
                
                const wasScanning = this.isScanning;
                this.cleanupResources();
                
                if (wasScanning) {
                    setTimeout(async () => {
                        try {
                            await this.initializeCamera();
                            this.showStatus(`ã‚«ãƒ¡ãƒ© ${this.cameraIndex + 1}/${this.cameras.length} ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ`, 'success');
                        } catch (error) {
                            this.showStatus('ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆã‚¨ãƒ©ãƒ¼', 'error');
                            console.error('Camera switch error:', error);
                        }
                    }, 500);
                }
            }
            
            // Phase 2: ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰
            toggleDebug() {
                this.debugMode = !this.debugMode;
                this.debugPanel.classList.toggle('show', this.debugMode);
                
                if (this.debugMode) {
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    this.updateDebug('ios', isIOS ? 'Yes' : 'No');
                    this.startDebugUpdateLoop();
                } else {
                    if (this.debugUpdateInterval) {
                        clearInterval(this.debugUpdateInterval);
                        this.debugUpdateInterval = null;
                    }
                }
            }
            
            startDebugUpdateLoop() {
                if (this.debugUpdateInterval) clearInterval(this.debugUpdateInterval);
                
                this.debugUpdateInterval = setInterval(() => {
                    if (!this.debugMode) return;
                    
                    if (this.scanStartTime > 0) {
                        const uptime = Math.floor((Date.now() - this.scanStartTime) / 1000);
                        this.updateDebug('uptime', `${uptime}s`);
                    }
                    
                    if (this.video && this.video.videoWidth > 0) {
                        this.updateDebug('resolution', `${this.video.videoWidth}x${this.video.videoHeight}`);
                    }
                    
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    this.updateDebug('scanrate', `${isIOS ? 3 : 5}/sec`);
                    this.updateDebug('method', this.detectionMethod);
                    this.updateDebug('frames', this.frameCount);
                    
                    if (this.stream) {
                        const videoTrack = this.stream.getVideoTracks()[0];
                        if (videoTrack) {
                            this.updateDebug('camera', videoTrack.label || 'Unknown');
                            this.updateDebug('stream', 'Connected');
                        }
                    } else {
                        this.updateDebug('stream', 'Disconnected');
                    }
                    
                    if (this.video) {
                        this.updateDebug('ready', this.video.readyState);
                    }
                    
                    this.updateDebug('detection', this.isScanning ? 'Active' : 'Stopped');
                }, 1000);
            }
            
            updateDebug(type, value) {
                const element = document.getElementById(`debug-${type}`);
                if (element) element.textContent = value;
            }
            
            pauseScanning() {
                if (this.qrScanner) this.qrScanner.stop();
                this.scanLine.style.display = 'none';
                this.updateCameraStatus('ä¸€æ™‚åœæ­¢ä¸­...');
            }
            
            async resumeScanning() {
                if (this.qrScanner && this.isScanning) {
                    try {
                        await this.qrScanner.start();
                        this.scanLine.style.display = 'block';
                        this.updateCameraStatus('QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ä¸­...');
                    } catch (error) {
                        console.warn('Resume scanning failed:', error);
                        this.calibrateCamera();
                    }
                }
            }
            
            stopScan() {
                this.isScanning = false;
                this.isCalibrating = false;
                
                if (this.scanLine) this.scanLine.style.display = 'none';
                if (this.calibrationOverlay) this.calibrationOverlay.style.display = 'none';
                
                if (this.debugUpdateInterval) {
                    clearInterval(this.debugUpdateInterval);
                    this.debugUpdateInterval = null;
                }
                
                this.cleanupResources();
            }
            
            cleanupResources() {
                console.log('[Cleanup] Cleaning up resources...');
                
                if (this.qrScanner) {
                    try {
                        this.qrScanner.stop();
                        this.qrScanner.destroy();
                    } catch (error) {
                        console.warn('[Cleanup] QrScanner cleanup error:', error);
                    }
                    this.qrScanner = null;
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => {
                        track.stop();
                        console.log(`[Cleanup] Stopped track: ${track.kind} - ${track.label}`);
                    });
                    this.stream = null;
                }
                
                if (this.video && this.video.srcObject) {
                    this.video.srcObject = null;
                    this.video.pause();
                }
                
                this.updateDebug('stream', 'Disconnected');
                this.updateDebug('detection', 'Stopped');
                this.updateDebug('method', '-');
                this.detectionMethod = 'none';
            }
            
            handleError(error) {
                this.stopScan();
                
                let message = 'ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚';
                
                switch (error.name) {
                    case 'NotAllowedError':
                        message = 'ã‚«ãƒ¡ãƒ©ã®ä½¿ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‹ã‚‰ã‚«ãƒ¡ãƒ©ã®è¨±å¯ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„ã€‚';
                        break;
                    case 'NotFoundError':
                        message = 'ã‚«ãƒ¡ãƒ©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ‡ãƒã‚¤ã‚¹ã«ã‚«ãƒ¡ãƒ©ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                        break;
                    case 'NotSupportedError':
                        message = 'ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã‚«ãƒ¡ãƒ©æ©Ÿèƒ½ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚';
                        break;
                    case 'NotReadableError':
                        message = 'ã‚«ãƒ¡ãƒ©ãŒä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ç”¨ä¸­ã§ã™ã€‚';
                        break;
                    case 'SecurityError':
                        message = 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ã«ã‚ˆã‚Šã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚HTTPSç’°å¢ƒãŒå¿…è¦ã§ã™ã€‚';
                        break;
                }
                
                this.errorMessageText.textContent = message;
                this.showScreen('error');
                console.error('[Error]', error);
            }
            
            rescan() {
                // ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã‚’å®Œå…¨ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã—ã¦ã‹ã‚‰åˆæœŸç”»é¢ã«æˆ»ã‚‹
                this.isScanning = false;
                this.isCalibrating = false;
                this.calibrationAttempts = 0;
                this.frameCount = 0;
                this.lastQRValue = '';
                
                // ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                this.cleanupResources();
                
                // åˆæœŸç”»é¢ã«æˆ»ã‚‹
                this.showScreen('start');
                
                console.log('[Rescan] Reset to initial state');
            }
            
            async copyToClipboard() {
                try {
                    await navigator.clipboard.writeText(this.lastQRValue);
                    const btn = this.buttons.copyResult;
                    const originalText = btn.textContent;
                    btn.textContent = 'âœ… ã‚³ãƒ”ãƒ¼å®Œäº†!';
                    btn.style.background = '#10b981';
                    
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 2000);
                } catch (error) {
                    console.error('ã‚³ãƒ”ãƒ¼å¤±æ•—:', error);
                    alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                }
            }
            
            async shareResult() {
                try {
                    await navigator.share({
                        title: 'QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šçµæœ',
                        text: this.lastQRValue
                    });
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error('å…±æœ‰å¤±æ•—:', error);
                    }
                }
            }
        }
        
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            window.qrScannerApp = new QRScannerApp();
        });
    </script>
</body>
</html>
