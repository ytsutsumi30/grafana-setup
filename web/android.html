<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QRã‚³ãƒ¼ãƒ‰ã‚¹ã‚­ãƒ£ãƒŠãƒ¼ï¼ˆAndroid / Chromeå¯¾å¿œç‰ˆï¼‰</title>
    
    <!-- ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯¾ç­– -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/qr-scanner@1.4.2/qr-scanner.umd.min.js"></script>
    <style>
        .scan-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 240px;
            height: 240px;
            border: 2px dashed rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            pointer-events: none;
        }
        
        .scan-corners {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 240px;
            height: 240px;
            pointer-events: none;
        }
        
        .corner {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 3px solid #60a5fa;
        }
        
        .corner-tl { top: -3px; left: -3px; border-right: none; border-bottom: none; }
        .corner-tr { top: -3px; right: -3px; border-left: none; border-bottom: none; }
        .corner-bl { bottom: -3px; left: -3px; border-right: none; border-top: none; }
        .corner-br { bottom: -3px; right: -3px; border-left: none; border-top: none; }
        
        @keyframes scanning {
            0% { background-position: 0% 0%; }
            100% { background-position: 0% 100%; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .scanning-line {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 240px;
            height: 240px;
            background: linear-gradient(180deg, transparent 0%, transparent 45%, #60a5fa 50%, transparent 55%, transparent 100%);
            background-size: 100% 200%;
            animation: scanning 2s linear infinite;
            border-radius: 12px;
            pointer-events: none;
        }
        
        .calibrating {
            animation: pulse 1s ease-in-out infinite;
        }
        
        .video-container {
            position: relative;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 16/9;
        }
        
        .permission-guide {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        }
        
        .debug-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff00;
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            max-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.4;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .debug-info .debug-title {
            color: #ffff00;
            font-weight: bold;
            border-bottom: 1px solid #444;
            padding-bottom: 4px;
            margin-bottom: 6px;
        }
        
        .debug-info .debug-section {
            margin-bottom: 8px;
        }
        
        .debug-info .debug-label {
            color: #00ccff;
            display: inline-block;
            min-width: 100px;
        }
        
        .debug-info .debug-value {
            color: #00ff00;
        }
        
        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¹ã‚¿ã‚¤ãƒ« (itemqr.htmlçµ±åˆ) */
        #qr-status-message {
            animation: slideDown 0.3s ease-out;
        }
        
        #qr-status-message.info {
            background-color: #dbeafe;
            color: #1e40af;
            border: 1px solid #60a5fa;
        }
        
        #qr-status-message.success {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #34d399;
        }
        
        #qr-status-message.error {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #f87171;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div id="app" class="min-h-screen flex flex-col">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <div class="bg-white shadow-sm border-b border-gray-200">
            <div class="px-4 py-4">
                <h1 class="text-xl font-bold text-gray-900 text-center flex items-center justify-center gap-2">
                    <span class="text-2xl">ğŸ“±</span>
                    QRã‚¹ã‚­ãƒ£ãƒŠãƒ¼ï¼ˆAndroid / Chromeï¼‰
                </h1>
                <div class="text-xs text-gray-500 text-center mt-1">
                    <span id="build-version">æ§‹ç¯‰æ—¥æ™‚: 2025-10-18 03:30 JST</span> | 
                    <span id="page-loaded">èª­è¾¼: <span id="load-time"></span></span>
                </div>
            </div>
        </div>

        <div class="flex-1 p-4 space-y-4">
            <!-- åˆæœŸç”»é¢ -->
            <div id="initial-screen" class="text-center py-8">
                <div class="bg-white rounded-xl shadow-sm p-8 mb-6">
                    <div class="text-6xl mb-4">ğŸ“·</div>
                    <h2 class="text-xl font-semibold mb-3 text-gray-900">QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³</h2>
                    <p class="text-gray-600 mb-6 max-w-sm mx-auto">
                        Android / Chrome å‘ã‘ã«èª¿æ•´æ¸ˆã¿ã®é«˜é€ŸQRã‚¹ã‚­ãƒ£ãƒ³ã§ã™
                    </p>
                    <button id="start-scan" class="bg-blue-600 text-white px-8 py-4 rounded-xl font-medium hover:bg-blue-700 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:-translate-y-0.5">
                        ğŸ“· ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹
                    </button>
                </div>
                
                <!-- Android / Chrome æ¨å¥¨äº‹é … -->
                <div class="bg-emerald-50 border border-emerald-200 rounded-xl shadow-sm p-6 text-left max-w-md mx-auto">
                    <h3 class="font-semibold text-emerald-800 mb-3">ğŸ¤– Android / Chrome æ¨å¥¨è¨­å®š</h3>
                    <ul class="text-sm text-emerald-700 space-y-1">
                        <li>â€¢ ã‚«ãƒ¡ãƒ©è¨±å¯ã‚’ã€Œè¨±å¯ã€ã«è¨­å®šã—ã¦ãã ã•ã„</li>
                        <li>â€¢ ç”»é¢å›è»¢ã‚’å›ºå®šã™ã‚‹ã¨QRãŒåˆã‚ã›ã‚„ã™ããªã‚Šã¾ã™</li>
                        <li>â€¢ å¤±æ•—æ™‚ã¯ã€Œå†èª¿æ•´ã€ãƒœã‚¿ãƒ³ã§ã‚«ãƒ¡ãƒ©ã‚’ãƒªã‚»ãƒƒãƒˆã§ãã¾ã™</li>
                    </ul>
                </div>
            </div>

            <!-- ã‚«ãƒ¡ãƒ©ç”»é¢ -->
            <div id="camera-screen" class="hidden">
                <div class="video-container mb-4">
                    <video id="camera-video" class="w-full h-full object-cover" playsinline muted webkit-playsinline></video>
                    <div class="scan-guide"></div>
                    <div class="scan-corners">
                        <div class="corner corner-tl"></div>
                        <div class="corner corner-tr"></div>
                        <div class="corner corner-bl"></div>
                        <div class="corner corner-br"></div>
                    </div>
                    <div id="scanning-animation" class="scanning-line hidden"></div>
                    
                    <!-- ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤º -->
                    <div id="calibration-indicator" class="hidden absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center">
                        <div class="bg-white rounded-lg p-6 text-center calibrating">
                            <div class="text-4xl mb-2">âš™ï¸</div>
                            <div class="text-lg font-semibold mb-1">ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­</div>
                            <div class="text-sm text-gray-600">ã‚«ãƒ¡ãƒ©ã‚’èª¿æ•´ã—ã¦ã„ã¾ã™...</div>
                        </div>
                    </div>
                    
                    <!-- ãƒ‡ãƒãƒƒã‚°æƒ…å ±ï¼ˆPhase 2æ‹¡å¼µç‰ˆï¼‰ -->
                    <div id="debug-info" class="debug-info hidden">
                        <div class="debug-title">ğŸ› Debug Info</div>
                        
                        <div class="debug-section">
                            <div class="debug-label">ğŸ“¹ Camera:</div>
                            <div class="debug-value" id="debug-camera">-</div>
                        </div>
                        
                        <div class="debug-section">
                            <div class="debug-label">ğŸ“ Resolution:</div>
                            <div class="debug-value" id="debug-resolution">-</div>
                        </div>
                        
                        <div class="debug-section">
                            <div class="debug-label">ğŸ¬ ReadyState:</div>
                            <div class="debug-value" id="debug-ready">-</div>
                        </div>
                        
                        <div class="debug-section">
                            <div class="debug-label">ğŸ“¡ Stream:</div>
                            <div class="debug-value" id="debug-stream">-</div>
                        </div>
                        
                        <div class="debug-section">
                            <div class="debug-label">ğŸ” Detection:</div>
                            <div class="debug-value" id="debug-detection">-</div>
                        </div>
                        
                        <div class="debug-section">
                            <div class="debug-label">ğŸ”¢ Frames:</div>
                            <div class="debug-value" id="debug-frames">0</div>
                        </div>
                        
                        <div class="debug-section">
                            <div class="debug-label">ğŸ“Š Scan Rate:</div>
                            <div class="debug-value" id="debug-scanrate">-</div>
                        </div>
                        
                        <div class="debug-section">
                            <div class="debug-label">âš¡ Method:</div>
                            <div class="debug-value" id="debug-method">-</div>
                        </div>
                        
                        <div class="debug-section">
                            <div class="debug-label">ğŸ¤– Platform:</div>
                            <div class="debug-value" id="debug-platform">-</div>
                        </div>
                        
                        <div class="debug-section">
                            <div class="debug-label">â±ï¸ Uptime:</div>
                            <div class="debug-value" id="debug-uptime">0s</div>
                        </div>
                    </div>
                    
                    <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º -->
                    <div id="scan-status" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-70 text-white px-4 py-2 rounded-full text-sm font-medium">
                        åˆæœŸåŒ–ä¸­...
                    </div>
                </div>
                
                <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆitemqr.htmlçµ±åˆï¼‰ -->
                <div id="qr-status-message" class="hidden mb-4 p-3 rounded-lg text-center font-medium"></div>
                
                <div class="text-center space-y-4">
                    <p class="text-gray-600">QRã‚³ãƒ¼ãƒ‰ã‚’ç”»é¢ä¸­å¤®ã®æ å†…ã«åˆã‚ã›ã¦ãã ã•ã„</p>
                    <div class="flex gap-3 justify-center flex-wrap">
                        <button id="calibrate-camera" class="bg-yellow-600 text-white px-4 py-2 rounded-lg hover:bg-yellow-700 transition-colors">
                            âš™ï¸ å†èª¿æ•´
                        </button>
                        <button id="switch-camera" class="bg-teal-600 text-white px-4 py-2 rounded-lg hover:bg-teal-700 transition-colors">
                            ğŸ”„ ã‚«ãƒ¡ãƒ©åˆ‡æ›¿
                        </button>
                        <button id="manual-input" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors">
                            âœï¸ æ‰‹å‹•å…¥åŠ›
                        </button>
                        <button id="toggle-debug" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition-colors">
                            ğŸ› Debug
                        </button>
                        <button id="stop-scan" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition-colors">
                            â¹ï¸ åœæ­¢
                        </button>
                    </div>
                </div>
            </div>

            <!-- çµæœç”»é¢ -->
            <div id="result-screen" class="hidden text-center">
                <div class="bg-white rounded-xl shadow-sm p-8 mb-6">
                    <div class="text-6xl mb-4">âœ…</div>
                    <h2 class="text-xl font-semibold mb-4 text-gray-900">ã‚¹ã‚­ãƒ£ãƒ³å®Œäº†</h2>
                    
                    <div class="bg-gray-50 rounded-lg p-4 mb-6">
                        <h3 class="font-medium text-gray-700 mb-3">ğŸ“„ èª­ã¿å–ã‚Šçµæœ</h3>
                        <div class="bg-white border rounded-lg p-4 text-left">
                            <pre id="scan-result" class="whitespace-pre-wrap text-sm text-gray-800 break-all max-h-40 overflow-y-auto"></pre>
                        </div>
                    </div>
                    
                    <div class="space-y-3">
                        <button id="copy-result" class="bg-blue-600 text-white px-6 py-3 rounded-xl hover:bg-blue-700 transition-colors w-full font-medium">
                            ğŸ“‹ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
                        </button>
                        <div class="flex gap-3">
                            <button id="rescan" class="bg-gray-600 text-white px-4 py-3 rounded-xl hover:bg-gray-700 transition-colors flex-1">
                                ğŸ”„ å†ã‚¹ã‚­ãƒ£ãƒ³
                            </button>
                            <button id="share-result" class="bg-green-600 text-white px-4 py-3 rounded-xl hover:bg-green-700 transition-colors flex-1">
                                ğŸ“¤ å…±æœ‰
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ã‚¨ãƒ©ãƒ¼ç”»é¢ -->
            <div id="error-screen" class="hidden text-center">
                <div class="bg-white rounded-xl shadow-sm p-8 mb-6">
                    <div class="text-6xl mb-4">âŒ</div>
                    <h2 class="text-xl font-semibold mb-3 text-gray-900">ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼</h2>
                    <p id="error-message" class="text-red-600 mb-6"></p>
                    
                    <div class="permission-guide rounded-xl p-6 text-left mb-6">
                        <h3 class="font-semibold text-blue-900 mb-3">ğŸ”§ è§£æ±ºæ–¹æ³•ï¼ˆAndroid / Chromeï¼‰</h3>
                        <ol class="text-sm text-blue-800 space-y-2">
                            <li><strong>1.</strong> ãƒ–ãƒ©ã‚¦ã‚¶å³ä¸Šã®ï¸™ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã</li>
                            <li><strong>2.</strong> ã€Œè¨­å®šã€ã¾ãŸã¯ã€Œã‚µã‚¤ãƒˆã®è¨­å®šã€ã‚’é¸æŠ</li>
                            <li><strong>3.</strong> ã€Œã‚«ãƒ¡ãƒ©ã€ã‚’é–‹ãã€ã“ã®ã‚µã‚¤ãƒˆã‚’ã€Œè¨±å¯ã€ã«è¨­å®š</li>
                            <li><strong>4.</strong> ã‚¿ãƒ–ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦å†åº¦ã‚¹ã‚­ãƒ£ãƒ³</li>
                            <li><strong>5.</strong> ãã‚Œã§ã‚‚å¤±æ•—ã™ã‚‹å ´åˆã¯ç«¯æœ«ã‚’å†èµ·å‹•</li>
                        </ol>
                    </div>
                    
                    <div class="space-y-3">
                        <button id="retry" class="bg-blue-600 text-white px-6 py-3 rounded-xl hover:bg-blue-700 transition-colors w-full">
                            ğŸ”„ å†è©¦è¡Œ
                        </button>
                        <button onclick="window.location.reload()" class="bg-gray-600 text-white px-6 py-3 rounded-xl hover:bg-gray-700 transition-colors w-full">
                            â™»ï¸ ãƒšãƒ¼ã‚¸å†èª­ã¿è¾¼ã¿
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ãƒ•ãƒƒã‚¿ãƒ¼ -->
        <div class="bg-white border-t border-gray-200 p-4 text-center">
            <p class="text-sm text-gray-500 mb-1">ğŸ”’ HTTPSç’°å¢ƒã§å®‰å…¨ã«å‹•ä½œ</p>
            <p class="text-xs text-gray-400">Android / Chromeå¯¾å¿œç‰ˆ v1.0</p>
        </div>
    </div>

    <script>
    class AndroidChromeQRScanner {
            constructor() {
                this.video = document.getElementById('camera-video');
                this.stream = null;
                this.isScanning = false;
                this.qrScanner = null;
                this.currentCamera = 'environment';
                this.cameras = [];
                this.cameraIndex = 0;  // Phase 2: ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆç”¨
                this.calibrationAttempts = 0;
                this.maxCalibrationAttempts = 3;
                this.frameCount = 0;
                this.lastDetectionAttempt = 0;
                this.isCalibrating = false;
                this.debugMode = false;
                this.lastQRValue = '';  // itemqr.htmlçµ±åˆ: æœ€å¾Œã®QRå€¤ã‚’ä¿æŒ
                this.scanStartTime = 0;  // Phase 2: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬
                this.detectionMethod = 'none';  // Phase 2: ä½¿ç”¨ä¸­ã®æ¤œå‡ºæ–¹æ³•
                this.platform = this.detectPlatform();
                
                this.initElements();
                this.initEventListeners();
                this.initPageLifecycleHandling();
                this.detectCameras();
            }

            detectPlatform() {
                const ua = navigator.userAgent || '';
                const isAndroid = /Android/i.test(ua);
                const isChrome = /Chrome|CriOS|EdgA/i.test(ua);
                const labelParts = [];
                if (isAndroid) labelParts.push('Android');
                if (isChrome) labelParts.push('Chrome');
                return {
                    isAndroid,
                    isChrome,
                    label: labelParts.length ? labelParts.join(' + ') : 'Other'
                };
            }

            initElements() {
                this.initialScreen = document.getElementById('initial-screen');
                this.cameraScreen = document.getElementById('camera-screen');
                this.resultScreen = document.getElementById('result-screen');
                this.errorScreen = document.getElementById('error-screen');
                this.scanStatus = document.getElementById('scan-status');
                this.scanResult = document.getElementById('scan-result');
                this.errorMessage = document.getElementById('error-message');
                this.scanningAnimation = document.getElementById('scanning-animation');
                this.calibrationIndicator = document.getElementById('calibration-indicator');
                this.debugInfo = document.getElementById('debug-info');
                this.qrStatusMessage = document.getElementById('qr-status-message');  // itemqr.htmlçµ±åˆ
                
                // Phase 2: æ‹¡å¼µãƒ‡ãƒãƒƒã‚°è¦ç´ 
                this.debugElements = {
                    camera: document.getElementById('debug-camera'),
                    resolution: document.getElementById('debug-resolution'),
                    ready: document.getElementById('debug-ready'),
                    stream: document.getElementById('debug-stream'),
                    detection: document.getElementById('debug-detection'),
                    frames: document.getElementById('debug-frames'),
                    scanrate: document.getElementById('debug-scanrate'),
                    method: document.getElementById('debug-method'),
                    platform: document.getElementById('debug-platform'),
                    uptime: document.getElementById('debug-uptime')
                };
            }

            initEventListeners() {
                document.getElementById('start-scan').addEventListener('click', () => this.startScan());
                document.getElementById('stop-scan').addEventListener('click', () => this.stopScan());
                document.getElementById('calibrate-camera').addEventListener('click', () => this.calibrateCamera());
                document.getElementById('switch-camera').addEventListener('click', () => this.switchCamera());  // Phase 2
                document.getElementById('toggle-debug').addEventListener('click', () => this.toggleDebug());
                document.getElementById('retry').addEventListener('click', () => this.resetAndStart());
                document.getElementById('rescan').addEventListener('click', () => this.resetAndStart());
                document.getElementById('copy-result').addEventListener('click', () => this.copyToClipboard());
                document.getElementById('share-result').addEventListener('click', () => this.shareResult());
                document.getElementById('manual-input').addEventListener('click', () => this.manualQRInput());  // itemqr.htmlçµ±åˆ
            }

            // ãƒšãƒ¼ã‚¸ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†ï¼ˆãƒ¢ãƒã‚¤ãƒ«ãƒ–ãƒ©ã‚¦ã‚¶å‘ã‘ï¼‰
            initPageLifecycleHandling() {
                // Page Visibility API
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        if (this.isScanning) {
                            this.pauseScanning();
                        }
                    } else {
                        if (this.isScanning) {
                            setTimeout(() => this.resumeScanning(), 500);
                        }
                    }
                });

                // ãƒ¢ãƒã‚¤ãƒ«ãƒ–ãƒ©ã‚¦ã‚¶å‘ã‘ã®beforeunloadå¯¾ç­–
                window.addEventListener('beforeunload', () => {
                    this.cleanupResources();
                });

                // BFCacheå¯¾å¿œ: pagehide/pageshowã‚¤ãƒ™ãƒ³ãƒˆ
                window.addEventListener('pagehide', (event) => {
                    // BFCacheä¿å­˜æ™‚ã¯ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    console.log('[BFCache] pagehide - persisted:', event.persisted);
                    this.cleanupResources();
                    
                    // ã‚¹ã‚­ãƒ£ãƒ³çŠ¶æ…‹ã‚’ä¿å­˜
                    if (this.isScanning) {
                        sessionStorage.setItem('qr-scanner-was-active', 'true');
                    }
                });

                window.addEventListener('pageshow', (event) => {
                    // BFCacheã‹ã‚‰å¾©å…ƒã•ã‚ŒãŸå ´åˆ
                    if (event.persisted) {
                        console.log('[BFCache] pageshow - restored from cache');
                        
                        // ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒæ®‹ã£ã¦ã„ã‚Œã°å®Œå…¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                        this.cleanupResources();
                        
                        // å‰å›ã‚¹ã‚­ãƒ£ãƒ³ä¸­ã ã£ãŸå ´åˆã¯è‡ªå‹•å†é–‹
                        const wasActive = sessionStorage.getItem('qr-scanner-was-active');
                        if (wasActive === 'true') {
                            sessionStorage.removeItem('qr-scanner-was-active');
                            setTimeout(() => {
                                this.resetAndStart();
                            }, 300);
                        } else {
                            // åˆæœŸç”»é¢ã«æˆ»ã™
                            this.showScreen('initial-screen');
                        }
                    }
                });

                // freeze/resume ã‚¤ãƒ™ãƒ³ãƒˆ (Android Chromeå¯¾å¿œ)
                window.addEventListener('freeze', () => {
                    console.log('[BFCache] freeze - cleaning up');
                    this.cleanupResources();
                });

                window.addEventListener('resume', () => {
                    console.log('[BFCache] resume - checking state');
                    if (this.isScanning) {
                        this.calibrateCamera();
                    }
                });
            }

            async detectCameras() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.cameras = devices.filter(device => device.kind === 'videoinput');
                    
                    console.log(`[Camera] Detected ${this.cameras.length} camera(s):`, this.cameras);
                    this.updateDebug('camera', `${this.cameras.length} camera(s)`);
                    this.updateDebug('detection', `${this.cameras.length} cameras found`);
                    
                    // èƒŒé¢ã‚«ãƒ¡ãƒ©ã‚’å„ªå…ˆçš„ã«é¸æŠ
                    const backCameraIndex = this.cameras.findIndex(cam => 
                        cam.label.toLowerCase().includes('back') || 
                        cam.label.toLowerCase().includes('rear') ||
                        cam.label.toLowerCase().includes('environment')
                    );
                    
                    if (backCameraIndex !== -1) {
                        this.cameraIndex = backCameraIndex;
                        console.log(`[Camera] Found back camera at index ${backCameraIndex}`);
                    }
                } catch (error) {
                    console.warn('ã‚«ãƒ¡ãƒ©æ¤œå‡ºã‚¨ãƒ©ãƒ¼:', error);
                    this.updateDebug('detection', 'Camera detection failed');
                }
            }

            showScreen(screenName) {
                ['initial-screen', 'camera-screen', 'result-screen', 'error-screen'].forEach(id => {
                    document.getElementById(id).classList.add('hidden');
                });
                document.getElementById(screenName).classList.remove('hidden');
            }

            updateStatus(message) {
                this.scanStatus.textContent = message;
            }

            updateDebug(type, value) {
                if (this.debugElements[type]) {
                    this.debugElements[type].textContent = value;
                }
            }

            toggleDebug() {
                this.debugMode = !this.debugMode;
                this.debugInfo.classList.toggle('hidden', !this.debugMode);
                
                if (this.debugMode) {
                    // ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æƒ…å ±ã‚’è¡¨ç¤º
                    this.updateDebug('platform', this.platform.label);
                    
                    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®å®šæœŸæ›´æ–°é–‹å§‹
                    this.startDebugUpdateLoop();
                } else {
                    // ãƒ‡ãƒãƒƒã‚°ãƒ«ãƒ¼ãƒ—åœæ­¢
                    if (this.debugUpdateInterval) {
                        clearInterval(this.debugUpdateInterval);
                        this.debugUpdateInterval = null;
                    }
                }
            }

            // Phase 2: ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®å®šæœŸæ›´æ–°
            startDebugUpdateLoop() {
                if (this.debugUpdateInterval) {
                    clearInterval(this.debugUpdateInterval);
                }
                
                this.debugUpdateInterval = setInterval(() => {
                    if (!this.debugMode) return;
                    
                    // ã‚¢ãƒƒãƒ—ã‚¿ã‚¤ãƒ è¨ˆç®—
                    if (this.scanStartTime > 0) {
                        const uptime = Math.floor((Date.now() - this.scanStartTime) / 1000);
                        this.updateDebug('uptime', `${uptime}s`);
                    }
                    
                    // è§£åƒåº¦æƒ…å ±
                    if (this.video.videoWidth > 0) {
                        this.updateDebug('resolution', `${this.video.videoWidth}x${this.video.videoHeight}`);
                    }
                    
                    // ã‚¹ã‚­ãƒ£ãƒ³ãƒ¬ãƒ¼ãƒˆæƒ…å ±
                    const scanRate = this.platform.isAndroid ? 5 : 6;
                    this.updateDebug('scanrate', `${scanRate}/sec`);
                    
                    // æ¤œå‡ºæ–¹æ³•
                    this.updateDebug('method', this.detectionMethod);

                    // ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
                    this.updateDebug('platform', this.platform.label);
                }, 1000);
            }

            // Phase 2: ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
            async switchCamera() {
                if (this.cameras.length <= 1) {
                    this.showQRStatus('åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ãªã‚«ãƒ¡ãƒ©ãŒã‚ã‚Šã¾ã›ã‚“', 'info');
                    return;
                }
                
                this.showQRStatus('ã‚«ãƒ¡ãƒ©ã‚’åˆ‡ã‚Šæ›¿ãˆã¦ã„ã¾ã™...', 'info');
                
                // æ¬¡ã®ã‚«ãƒ¡ãƒ©ã¸
                this.cameraIndex = (this.cameraIndex + 1) % this.cameras.length;
                
                // ã‚¹ã‚­ãƒ£ãƒ³ã‚’åœæ­¢ã—ã¦å†é–‹
                const wasScanning = this.isScanning;
                this.cleanupResources();
                
                if (wasScanning) {
                    // åˆ‡ã‚Šæ›¿ãˆå¾Œã«å†ã‚¹ã‚¿ãƒ¼ãƒˆ
                    setTimeout(async () => {
                        try {
                            await this.initializeCamera();
                            this.showQRStatus(`ã‚«ãƒ¡ãƒ© ${this.cameraIndex + 1}/${this.cameras.length} ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ`, 'success');
                        } catch (error) {
                            this.showQRStatus('ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆã‚¨ãƒ©ãƒ¼', 'error');
                            console.error('Camera switch error:', error);
                        }
                    }, 500);
                }
            }

            // ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ–: æ®µéšçš„ãªã‚«ãƒ¡ãƒ©åˆæœŸåŒ–
            async startScan() {
                try {
                    this.calibrationAttempts = 0;
                    this.frameCount = 0;
                    this.scanStartTime = Date.now();  // Phase 2: ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹æ™‚åˆ»ã‚’è¨˜éŒ²
                    this.updateStatus('ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...');
                    
                    await this.initializeCamera();
                    
                } catch (error) {
                    this.handleError(error);
                }
            }

            async initializeCamera() {
                // Phase 2: è¤‡æ•°ã‚«ãƒ¡ãƒ©å¯¾å¿œ
                let constraints;
                
                if (this.cameras.length > 0 && this.cameras[this.cameraIndex]) {
                    // ç‰¹å®šã®ã‚«ãƒ¡ãƒ©IDã§æŒ‡å®š
                    constraints = {
                        video: {
                            deviceId: { exact: this.cameras[this.cameraIndex].deviceId },
                            width: { ideal: 1280, max: 1920 },
                            height: { ideal: 720, max: 1080 },
                            frameRate: { ideal: 30, max: 30 }
                        }
                    };
                    console.log(`[Camera] Using camera ${this.cameraIndex}: ${this.cameras[this.cameraIndex].label}`);
                } else {
                    // facingModeã§æŒ‡å®šï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                    constraints = {
                        video: {
                            facingMode: this.currentCamera,
                            width: { ideal: 1280, max: 1920 },
                            height: { ideal: 720, max: 1080 },
                            frameRate: { ideal: 30, max: 30 }
                        }
                    };
                    console.log(`[Camera] Using facingMode: ${this.currentCamera}`);
                }

                try {
                    // ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å–å¾—
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    this.updateDebug('stream', 'Connected');
                    
                    // ã‚«ãƒ¡ãƒ©æƒ…å ±ã‚’æ›´æ–°
                    const videoTrack = this.stream.getVideoTracks()[0];
                    const settings = videoTrack.getSettings();
                    this.updateDebug('camera', videoTrack.label || 'Unknown');
                    console.log('[Camera] Settings:', settings);

                    // ãƒ¢ãƒã‚¤ãƒ«ãƒ–ãƒ©ã‚¦ã‚¶ã§ã®äº’æ›æ€§ç¢ºä¿
                    this.video.setAttribute('playsinline', true);
                    this.video.setAttribute('webkit-playsinline', true);
                    this.video.muted = true;

                    // ã‚ˆã‚Šç¢ºå®ŸãªåˆæœŸåŒ–å¾…æ©Ÿ
                    await this.waitForVideoReady();
                    
                    this.showScreen('camera-screen');
                    this.isScanning = true;
                    
                    // å®‰å®šåŒ–ã®ãŸã‚ã®ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
                    await this.calibrateCamera();
                    
                } catch (error) {
                    console.error('[Camera] Initialization error:', error);
                    
                    // Phase 2: ã‚«ãƒ¡ãƒ©ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    if (this.cameras.length > 1 && this.cameraIndex < this.cameras.length - 1) {
                        console.log('[Camera] Trying next camera...');
                        this.cameraIndex++;
                        return this.initializeCamera();
                    }
                    
                    throw error;
                }
            }

            // ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ–: ã‚ˆã‚Šç¢ºå®Ÿãªãƒ“ãƒ‡ã‚ªæº–å‚™å¾…æ©Ÿ
            async waitForVideoReady() {
                return new Promise((resolve, reject) => {
                    let playbackStarted = false;

                    const timeout = setTimeout(() => {
                        const readyState = this.video.readyState;
                        console.warn('[Video] Initialization timeout, evaluating readiness...', readyState);
                        this.updateDebug('ready', readyState);

                        // readyState 2 (HAVE_CURRENT_DATA) ã¾ã§åˆ°é”ã—ã¦ã„ã‚Œã°ç¶šè¡Œ
                        if (readyState >= 2) {
                            console.warn('[Video] Proceeding with forced playback after timeout');
                            startPlayback();
                        } else {
                            reject(new Error('ãƒ“ãƒ‡ã‚ªåˆæœŸåŒ–ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'));
                        }
                    }, 15000); // 15ç§’ã«å»¶é•·

                    const startPlayback = () => {
                        if (playbackStarted) {
                            return;
                        }
                        playbackStarted = true;
                        clearTimeout(timeout);
                        this.video.play()
                            .then(() => {
                                console.log('[Video] Playback started successfully');
                                this.waitForFirstFrame().then(resolve).catch(reject);
                            })
                            .catch(error => {
                                console.warn('[Video] Playback error, continuing anyway:', error);
                                this.waitForFirstFrame().then(resolve).catch(reject);
                            });
                    };

                    const checkReady = () => {
                        const readyState = this.video.readyState;
                        this.updateDebug('ready', readyState);

                        // readyState 3ä»¥ä¸Š AND videoWidth/HeightãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
                        if (readyState >= 3 && this.video.videoWidth > 0 && this.video.videoHeight > 0) {
                            console.log('[Video] Ready:', {
                                readyState,
                                size: `${this.video.videoWidth}x${this.video.videoHeight}`
                            });
                            startPlayback();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };

                    const onMetadataLoaded = () => {
                        console.log('[Video] Metadata loaded');
                        setTimeout(checkReady, 100);
                    };

                    this.video.addEventListener('loadedmetadata', onMetadataLoaded, { once: true });
                    checkReady(); // å³åº§ã«ãƒã‚§ãƒƒã‚¯é–‹å§‹
                });
            }

            // æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒæç”»ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿï¼ˆãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ–ï¼‰
            async waitForFirstFrame() {
                return new Promise((resolve) => {
                    let attempts = 0;
                    const maxAttempts = 50; // 5ç§’é–“è©¦è¡Œã«å»¶é•·

                    const checkFrame = () => {
                        attempts++;
                        
                        // videoWidth/HeightãŒæœ‰åŠ¹ã§ã€readyStateãŒ4ï¼ˆå®Œå…¨æº–å‚™å®Œäº†ï¼‰
                        if (this.video.readyState === 4 && this.video.videoWidth > 0 && this.video.videoHeight > 0) {
                            console.log(`[Video] First frame ready after ${attempts * 100}ms`);
                            this.updateDebug('resolution', `${this.video.videoWidth}x${this.video.videoHeight}`);
                            // ã•ã‚‰ã«å®‰å®šã‚’å¾…ã¤
                            setTimeout(resolve, 500);
                        } else if (attempts >= maxAttempts) {
                            console.warn('[Video] First frame timeout, proceeding anyway');
                            resolve(); // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¦ã‚‚ç¶šè¡Œ
                        } else {
                            setTimeout(checkFrame, 100);
                        }
                    };

                    // å³åº§ã«ãƒã‚§ãƒƒã‚¯é–‹å§‹
                    setTimeout(checkFrame, 100);
                });
            }

            // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ï¼ˆãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ–ã®æ ¸å¿ƒï¼‰
            async calibrateCamera() {
                if (this.isCalibrating || this.calibrationAttempts >= this.maxCalibrationAttempts) {
                    return this.startQRDetection();
                }

                this.isCalibrating = true;
                this.calibrationAttempts++;
                
                this.calibrationIndicator.classList.remove('hidden');
                this.updateStatus(`ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­... (${this.calibrationAttempts}/${this.maxCalibrationAttempts})`);

                // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æœŸé–“ã®å»¶é•·ï¼ˆåˆå›èµ·å‹•ã®å®‰å®šæ€§å‘ä¸Šï¼‰
                const calibrationDelay = this.calibrationAttempts === 1 ? 1500 : 800; // Androidå‘ã‘ã«çŸ­ç¸®
                console.log(`[Calibration] Waiting ${calibrationDelay}ms for camera stabilization...`);
                await new Promise(resolve => setTimeout(resolve, calibrationDelay));

                // ãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒå®Œå…¨ã«å®‰å®šã—ã¦ã„ã‚‹ã‹ç¢ºèª
                const isFullyReady = this.video.readyState === 4 && 
                                    this.video.videoWidth > 0 && 
                                    this.video.videoHeight > 0 &&
                                    !this.video.paused;

                this.calibrationIndicator.classList.add('hidden');
                this.isCalibrating = false;

                if (isFullyReady) {
                    console.log(`[Calibration] âœ… Success on attempt ${this.calibrationAttempts} - Video: ${this.video.videoWidth}x${this.video.videoHeight}`);
                    this.updateDebug('resolution', `${this.video.videoWidth}x${this.video.videoHeight}`);
                    // ã•ã‚‰ã«å°‘ã—å¾…æ©Ÿã—ã¦ã‹ã‚‰æ¤œå‡ºé–‹å§‹ï¼ˆå®‰å®šæ€§å‘ä¸Šï¼‰
                    setTimeout(() => this.startQRDetection(), 500);
                } else {
                    // ãƒ“ãƒ‡ã‚ªãŒã¾ã æº–å‚™ã§ãã¦ã„ãªã„å ´åˆã¯å†ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    console.warn(`[Calibration] âŒ Not ready (readyState: ${this.video.readyState}, size: ${this.video.videoWidth}x${this.video.videoHeight}, paused: ${this.video.paused})`);
                    if (this.calibrationAttempts < this.maxCalibrationAttempts) {
                        setTimeout(() => this.calibrateCamera(), 1000);
                    } else {
                        // æœ€å¤§è©¦è¡Œå›æ•°ã«é”ã—ãŸå ´åˆã§ã‚‚QRæ¤œå‡ºã‚’é–‹å§‹
                        console.warn('[Calibration] âš ï¸ Max attempts reached, starting detection anyway');
                        this.startQRDetection();
                    }
                }
            }

            async startQRDetection() {
                this.updateStatus('QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ä¸­...');
                this.scanningAnimation.classList.remove('hidden');
                this.updateDebug('detection', 'Starting');

                const scanRate = this.platform.isAndroid ? 5 : (this.platform.isChrome ? 6 : 5);

                if (typeof QrScanner !== 'undefined') {
                    try {
                        this.detectionMethod = 'QrScanner';

                        this.qrScanner = new QrScanner(
                            this.video,
                            result => this.handleQRResult(result.data),
                            {
                                returnDetailedScanResult: true,
                                highlightScanRegion: false,
                                highlightCodeOutline: false,
                                maxScansPerSecond: scanRate,
                                preferredCamera: 'environment',
                                calculateScanRegion: this.calculateScanRegion.bind(this)
                            }
                        );

                        await this.qrScanner.start();
                        this.updateDebug('detection', 'QrScanner active');
                        this.updateDebug('method', 'QrScanner');
                        this.showQRStatus('QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ä¸­...', 'info');

                        console.log(`[QR] QrScanner started (platform: ${this.platform.label}, rate: ${scanRate}/sec)`);

                        this.startFrameCounter();

                    } catch (error) {
                        console.warn('QR Scanner failed, using fallback:', error);
                        this.showQRStatus('QrScannerã‚¨ãƒ©ãƒ¼ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸­...', 'error');
                        this.fallbackToManualDetection();
                    }
                } else {
                    console.warn('QrScanner library not available, using fallback');
                    this.showQRStatus('QrScannerãƒ©ã‚¤ãƒ–ãƒ©ãƒªæœªæ¤œå‡ºã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸­...', 'error');
                    this.fallbackToManualDetection();
                }
            }

            // Phase 2: ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ– - ã‚¹ã‚­ãƒ£ãƒ³é ˜åŸŸã®å‹•çš„è¨ˆç®—
            calculateScanRegion(video) {
                const { videoWidth, videoHeight } = video;
                
                // å‹•ç”»ã®å‘ãï¼ˆç¸¦/æ¨ªï¼‰ã«å¿œã˜ã¦èª¿æ•´
                const isPortrait = videoHeight > videoWidth;
                const baseSize = Math.min(videoWidth, videoHeight);
                
                // ã‚¹ã‚­ãƒ£ãƒ³é ˜åŸŸã®ã‚µã‚¤ã‚ºï¼ˆç”»é¢ã®60%ï¼‰
                const size = Math.round(baseSize * 0.6);
                const x = Math.round((videoWidth - size) / 2);
                const y = Math.round((videoHeight - size) / 2);
                
                const region = {
                    x: Math.max(0, x),
                    y: Math.max(0, y),
                    width: Math.min(size, videoWidth),
                    height: Math.min(size, videoHeight)
                };
                
                console.log(`[Scan Region] ${region.width}x${region.height} at (${region.x}, ${region.y}) - Portrait: ${isPortrait}`);
                return region;
            }

            // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
            startFrameCounter() {
                const countFrames = () => {
                    if (this.isScanning) {
                        this.frameCount++;
                        this.updateDebug('frames', this.frameCount);
                        requestAnimationFrame(countFrames);
                    }
                };
                countFrames();
            }

            // Phase 2: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œå‡ºã®å¼·åŒ–
            fallbackToManualDetection() {
                if ('BarcodeDetector' in window) {
                    this.detectionMethod = 'BarcodeDetector';  // Phase 2: æ¤œå‡ºæ–¹æ³•ã‚’è¨˜éŒ²
                    
                    const detector = new BarcodeDetector({ formats: ['qr_code'] });
                    
                    const detectQR = async () => {
                        if (this.isScanning && this.video.readyState === 4) {
                            try {
                                const currentTime = Date.now();
                                // Androidå‘ã‘: 180msé–“éš”ï¼ˆç´„5.5å›/ç§’ï¼‰
                                if (currentTime - this.lastDetectionAttempt > 180) {
                                    const barcodes = await detector.detect(this.video);
                                    this.lastDetectionAttempt = currentTime;
                                    
                                    if (barcodes.length > 0) {
                                        console.log('[QR] Detected via BarcodeDetector:', barcodes[0].rawValue);
                                        this.handleQRResult(barcodes[0].rawValue);
                                        return;
                                    }
                                }
                            } catch (error) {
                                console.warn('BarcodeDetector error:', error);
                            }
                        }
                        
                        if (this.isScanning) {
                            requestAnimationFrame(detectQR);
                        }
                    };
                    
                    detectQR();
                    this.updateDebug('detection', 'BarcodeDetector active');
                    this.updateDebug('method', 'BarcodeDetector');
                    this.showQRStatus('BarcodeDetectorã§ã‚¹ã‚­ãƒ£ãƒ³ä¸­...', 'info');
                    console.log('[QR] Fallback to BarcodeDetector');
                    
                } else {
                    // Phase 2: ä¸¡æ–¹ä½¿ãˆãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
                    this.detectionMethod = 'none';
                    this.updateDebug('method', 'None (Error)');
                    console.error('[QR] No detection method available');
                    this.handleError(new Error('QRã‚³ãƒ¼ãƒ‰æ¤œå‡ºæ©Ÿèƒ½ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æœ€æ–°ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚'));
                }
            }

            handleQRResult(data) {
                // é‡è¤‡æ¤œå‡ºé˜²æ­¢
                if (!this.isScanning) return;
                
                this.lastQRValue = data;  // itemqr.htmlçµ±åˆ: QRå€¤ã‚’ä¿æŒ
                this.updateDebug('detection', 'QR detected!');
                this.showQRStatus('QRã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿å–ã‚Šã¾ã—ãŸ', 'success');  // itemqr.htmlçµ±åˆ
                this.showResult(data);
            }

            // itemqr.htmlçµ±åˆ: æ‰‹å‹•QRå…¥åŠ›æ©Ÿèƒ½
            manualQRInput() {
                const input = prompt('QRã‚³ãƒ¼ãƒ‰ã®å†…å®¹ã‚’æ‰‹å…¥åŠ›ã—ã¦ãã ã•ã„:');
                if (input && input.trim()) {
                    this.handleQRResult(input.trim());
                }
            }

            // itemqr.htmlçµ±åˆ: QRã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºï¼ˆ3ç§’è‡ªå‹•æ¶ˆå»ï¼‰
            showQRStatus(message, type) {
                if (!this.qrStatusMessage) return;
                
                this.qrStatusMessage.className = `p-3 rounded-lg text-center font-medium ${type}`;
                this.qrStatusMessage.textContent = message;
                this.qrStatusMessage.classList.remove('hidden');
                
                // 3ç§’å¾Œã«è‡ªå‹•éè¡¨ç¤º
                setTimeout(() => {
                    this.qrStatusMessage.classList.add('hidden');
                }, 3000);
            }

            // ã‚¹ã‚­ãƒ£ãƒ³ä¸€æ™‚åœæ­¢/å†é–‹
            pauseScanning() {
                if (this.qrScanner) {
                    this.qrScanner.stop();
                }
                this.scanningAnimation.classList.add('hidden');
                this.updateStatus('ä¸€æ™‚åœæ­¢ä¸­...');
            }

            async resumeScanning() {
                if (this.qrScanner && this.isScanning) {
                    try {
                        await this.qrScanner.start();
                        this.scanningAnimation.classList.remove('hidden');
                        this.updateStatus('QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ä¸­...');
                    } catch (error) {
                        console.warn('Resume scanning failed:', error);
                        this.calibrateCamera();
                    }
                }
            }

            stopScan() {
                this.isScanning = false;
                this.isCalibrating = false;
                this.scanningAnimation.classList.add('hidden');
                this.calibrationIndicator.classList.add('hidden');
                
                // Phase 2: ãƒ‡ãƒãƒƒã‚°ãƒ«ãƒ¼ãƒ—åœæ­¢
                if (this.debugUpdateInterval) {
                    clearInterval(this.debugUpdateInterval);
                    this.debugUpdateInterval = null;
                }
                
                this.cleanupResources();
                this.showQRStatus('QRã‚¹ã‚­ãƒ£ãƒ³ã‚’åœæ­¢ã—ã¾ã—ãŸ', 'info');  // itemqr.htmlçµ±åˆ
                this.showScreen('initial-screen');
            }

            cleanupResources() {
                console.log('[Cleanup] Cleaning up resources...');
                
                if (this.qrScanner) {
                    try {
                        this.qrScanner.stop();
                        this.qrScanner.destroy();
                    } catch (error) {
                        console.warn('[Cleanup] QrScanner cleanup error:', error);
                    }
                    this.qrScanner = null;
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => {
                        track.stop();
                        console.log(`[Cleanup] Stopped track: ${track.kind} - ${track.label}`);
                    });
                    this.stream = null;
                }
                
                // ãƒ“ãƒ‡ã‚ªè¦ç´ ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                if (this.video && this.video.srcObject) {
                    this.video.srcObject = null;
                }
                
                this.updateDebug('stream', 'Disconnected');
                this.updateDebug('detection', 'Stopped');
                this.updateDebug('method', '-');
                this.detectionMethod = 'none';
            }

            showResult(data) {
                this.stopScan();
                this.scanResult.textContent = data;
                this.showScreen('result-screen');
            }

            handleError(error) {
                this.stopScan();
                
                let message = 'ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚';
                
                switch (error.name) {
                    case 'NotAllowedError':
                        message = 'ã‚«ãƒ¡ãƒ©ã®ä½¿ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‹ã‚‰ã‚«ãƒ¡ãƒ©ã®è¨±å¯ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„ã€‚';
                        break;
                    case 'NotFoundError':
                        message = 'ã‚«ãƒ¡ãƒ©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ‡ãƒã‚¤ã‚¹ã«ã‚«ãƒ¡ãƒ©ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                        break;
                    case 'NotSupportedError':
                        message = 'ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã‚«ãƒ¡ãƒ©æ©Ÿèƒ½ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æœ€æ–°ã®Chromeã€Edgeã€ã¾ãŸã¯Firefoxã‚’ãŠè©¦ã—ãã ã•ã„ã€‚';
                        break;
                    case 'NotReadableError':
                        message = 'ã‚«ãƒ¡ãƒ©ãŒä»–ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ç”¨ä¸­ã§ã™ã€‚ä»–ã®ã‚¢ãƒ—ãƒªã‚’é–‰ã˜ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚';
                        break;
                    case 'SecurityError':
                        message = 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ã«ã‚ˆã‚Šã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚HTTPSç’°å¢ƒãŒå¿…è¦ã§ã™ã€‚';
                        break;
                }

                if (error.message && error.message.includes('QRã‚³ãƒ¼ãƒ‰æ¤œå‡º')) {
                    message = 'ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯QRã‚³ãƒ¼ãƒ‰æ¤œå‡ºã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚æœ€æ–°ã®Chromeã€Edgeã€ã¾ãŸã¯Firefoxã‚’ãŠè©¦ã—ãã ã•ã„ã€‚';
                }

                this.errorMessage.textContent = message;
                this.showScreen('error-screen');
            }

            resetAndStart() {
                this.stopScan();
                this.calibrationAttempts = 0;
                this.frameCount = 0;
                this.showScreen('initial-screen');
            }

            async copyToClipboard() {
                try {
                    await navigator.clipboard.writeText(this.scanResult.textContent);
                    const button = document.getElementById('copy-result');
                    const originalText = button.textContent;
                    button.textContent = 'âœ… ã‚³ãƒ”ãƒ¼å®Œäº†!';
                    button.classList.add('bg-green-600', 'hover:bg-green-700');
                    button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.classList.remove('bg-green-600', 'hover:bg-green-700');
                        button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                    }, 2000);
                } catch (error) {
                    console.error('ã‚³ãƒ”ãƒ¼å¤±æ•—:', error);
                    alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                }
            }

            async shareResult() {
                const text = this.scanResult.textContent;
                
                if (navigator.share) {
                    try {
                        await navigator.share({
                            title: 'QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šçµæœ',
                            text: text
                        });
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            console.error('å…±æœ‰å¤±æ•—:', error);
                        }
                    }
                } else {
                    this.copyToClipboard();
                }
            }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚åˆ»ã‚’è¡¨ç¤º
            const now = new Date();
            const loadTimeStr = now.toLocaleString('ja-JP', { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit',
                hour12: false 
            });
            document.getElementById('load-time').textContent = loadTimeStr;
            console.log('[Page] Loaded at:', loadTimeStr);
            
            new AndroidChromeQRScanner();
        });
    </script>
</body>
</html>